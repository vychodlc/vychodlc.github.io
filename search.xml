<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LearnGit</title>
      <link href="2021/11/11/LearnGit/"/>
      <url>2021/11/11/LearnGit/</url>
      
        <content type="html"><![CDATA[<h2 id="学习使用-Git-进行版本管理"><a href="#学习使用-Git-进行版本管理" class="headerlink" title="学习使用 Git 进行版本管理"></a>学习使用 Git 进行版本管理</h2><h3 id="什么是-Git-？"><a href="#什么是-Git-？" class="headerlink" title="什么是 Git ？"></a>什么是 Git ？</h3><p>既然要学习 Git ，那我们首先就肯定要知道 Git 是个什么东西。举个简单的例子，相信很多人都有过修改一个东西修改很多次的体验吧，最好的结果是最后达到了甲方的要求，但是没法保证甲方爸爸提出一句“第一版挺好的”，那么这个时候你就疯狂在电脑上找第一版，然后发现你始终用的是同一个文档进行修改，根本找不到第一版了。所以很多人开始养成了一些好习惯，一个作业进行的时候，每到一个关键点，就复制当前作业作为节点记录，也就是备份，这就是最简单的很容易想到的“版本管理”。但是这样带来的结果是，你的文件夹有一堆同样名字的文件，那么有的人会说了，我会按照时间把不同节点的文件起不一样的名字，这确实是一个很好的解决方法，但是你这个文件夹还是会有一大堆文件。如果你的单个文件比如说你的 word 很大，再如果你干了一个月每天都有两三个版本，那么你这一个月下来的文件占据存储空间的大小是非常庞大的。</p><p>多是一方面，难以管理是另一个大问题。老板说，你去给我找到 xxx 需求还没提出的那个版本，这个时候如果你想不起来是哪个时间，那么你的时间戳就毫无用处了；又有人要说了，我有版本管理文档，会记录每一版都修改了什么。你这么一说，还真把我说住了，不对，没有，完全没有，还是有个大问题，一个最大的问题，很多人都不是一个人在负责一份工作吧？肯定是有队友相互配合分工合作的吧？我们还是拿 word 举例子，比如说一个文件有三章，ABC三个人分别负责一章，最后怎么合并呢？简单的复制粘贴不就完了。那如果有一章三个人都参与修改了呢？那最后怎么合并呢？</p><p>2005年，Linus 花了两周的时间用 C 语言制作了 Git，这就是牛人吗？从这以后， Git 迅速成为了全世界最流行的分布式版本控制系统。2008年， Github 正式上线，成为了事到如今也是每个程序员心中最温暖的港湾（不是说抄代码哈）。</p><p>刚刚提到 Git 的时候有一个标签叫做 分布式，大家也可以很快想到它的反义词：集中式，那么这两种方式的版本控制系统到底有什么区别呢？</p><p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。曾经最常用的集中式版本控制系统有 CVS 和 SVN。</p><p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，砸电脑的心都有了。</p><p>这就足以体验分布式的好处了。首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><h3 id="Git-的安装"><a href="#Git-的安装" class="headerlink" title="Git 的安装"></a>Git 的安装</h3><p>鉴于我手头只有一台装有 win10 系统的工作本，所以我就只介绍一下 Windows 系统下的 Git 安装了，我们可以之间去<a href="https://git-scm.com/downloads">官网</a>下载安装包。</p><img src="/2021/11/11/LearnGit/image-20211111151524855.png" alt="image-20211111151524855" style="zoom:150%;"><p>当你开始菜单可以看到这几个小东西的时候，就说明你的 Git 已经安装好了。但是我们还需要进行一步操作，就是让你的 Git 有个标签，和这个世界上那么多的 Git 区分开来。让我们在命令行中输入下面两条命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;example@email.com&quot;</span></span><br></pre></td></tr></table></figure><p>配置完毕之后，你的 Git 也就可以见到其他 Git 的时候进行自我介绍了。</p><p>这里的 <code>--global</code> 参数是指全局配置，你电脑所有的 Git 仓库都会用这个配置，当然也可以对不同的仓库进行不一样的配置</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>找个你喜欢的地方生成一个空目录，然后进去，然后初始化</p><p><img src="/LearnGit/image-20211111153125533.png"></p><p>这样的话，这个 git_test 文件夹就变成了一个使用 Git 来进行版本管理的仓库了。随之变化的是该文件夹里面会有一个 .git 文件夹，这里面是 Git 用来跟踪管理版本的，咱尽量还是别去动它哈，咱动不起……</p><p>有人说我看不见这个文件，你可以选择把 文件夹上方工具栏 -&gt; 查看 -&gt; 勾选 “隐藏的项目”</p><p><img src="/2021/11/11/LearnGit/image-20211111153452014.png"></p><p>又有人说为什么我在命令行里面用高级的 linux 命令 ls 却看不见这个文件夹呢？这是因为它是默认隐藏的，如果你想看的话，你可以试试更高级的 ls -ah 哦</p><h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>随便在其他地方写好一个 readme.txt，再在里面写上两行自己想写的话，这里我打算写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>然后把它拖到 git_test 里面，再在终端 cd 到这个目录，将你想上传的文件 add 一下，就相当于告诉 Git，我要上传这个文件，你先拿笔给我记好咯！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>add 之后如果你想添加其他文件，你可以继续 add ，但是要确保你所 add 的文件存在于当前目录下；如果你想把当前文件夹里面的所有东西都 add 你可以选择高级的 <code>git add . </code> </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><p>这个高级的点，是很多人常用的吧，一键就完事了</p><p>如果你想知道现在 Git 都记下了什么文件，你可以使用一个 Git 命令来查询 <code>git status</code></p><p><img src="/2021/11/11/LearnGit/image-20211111155123594.png"></p><p>如果你想上传的东西都让 Git 记好了，那么你就可以让 Git 把你的这些东西上传到版本库里面去了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;this is my first commit&quot;</span></span><br></pre></td></tr></table></figure><p><code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录</p><p><img src="/2021/11/11/LearnGit/image-20211111155308739.png"></p><p><code>git commit</code> 命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><h3 id="Git-怎么干活的"><a href="#Git-怎么干活的" class="headerlink" title="Git 怎么干活的"></a>Git 怎么干活的</h3><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>这个时候再查询一下<code>git status</code></p><p><img src="/2021/11/11/LearnGit/image-20211111155633974.png"></p><p>我们可以大概看出的意思就是，我改了这个文件，但是没有上传到 commit 里面。</p><p>但如果是别人修改的呢？你要怎么才能知道别人进行了什么修改呢？我们就要学习一个新的 Git  命令了：<code>git diff</code>， diff 也就是 diffrence 嘛（疯狂炫耀扎实的小学英语基础）</p><p><img src="/2021/11/11/LearnGit/image-20211111155956748.png"></p><p>这里的话 减号 就是代表被修改的，加号 表示修改完的模样</p><p>修改完了，那我们肯定得提交啊，add commit 一气呵成，我太牛了把这也</p><p><img src="/2021/11/11/LearnGit/image-20211111162413594.png"></p><p>nothing to commit, working tree clean</p><p>完事了？下班！</p><p>不对还没下班，还有几个神奇功能没告诉大家呢！</p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>那么多此提交之后，那我该咋知道这个仓库的提交情况呢？让我们来试一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 如果想要简洁点可以试试下面这个</span></span><br><span class="line">$ git <span class="built_in">log</span> --pertty=oneline</span><br></pre></td></tr></table></figure><p>理论上来说我们可以看到三条提交信息</p><ol><li>最近一次的提交信息</li><li>上一次的提交信息</li><li>最早的一次的提交信息</li></ol><p>那么我想回到上一个版本的话，我该怎么做呢？</p><p>在 Git 中，使用 <code>HEAD</code> 代表当前版本，上一个版本是 <code>HEAD^</code> ，上上一个版本是 <code>HEAD^^</code> ，那么往前一百个呢？你当然可以选择使用100个 ^，但是这里我们更推荐使用 <code>HEAD~100</code> 。</p><p><img src="/2021/11/11/LearnGit/image-20211111163714436.png"></p><p>通过观察 id 号我们可以发现确实是实现了版本回退</p><p>这个时候你如果说，我不想回退了，我反悔了，嘿嘿，这颗有点麻烦咯，如果你使用 <code>git log</code> 你会发现刚刚那个 commit 消失了！</p><p>别急别急，我们往上滑，找到刚刚那条的 ID，deb08f…… 对对对，就是这个，看我来施展魔法</p><p><img src="/2021/11/11/LearnGit/image-20211111164134782.png"></p><p>嘿嘿！成功了</p><p>这里的 id 是使用 SHA1 进行编码的时间戳，可以支持一个模糊搜索，但是建议至少四五位这样子，要不然可能会找出来两条 id 前缀一样的 commit 信息</p><p>但是如果你关闭了电脑之后才后悔了咋办呢？别急，Git 还留了一手</p><p><img src="/2021/11/11/LearnGit/image-20211111164435244.png"></p><p>使用 <code>git reflog</code> 可以显示你在当前仓库执行的每一次命令</p><h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>工作区与暂存区其实不是同级的。根据工作逻辑我们可以有 工作区 和 版本库 两个分类。工作区 指单个用户在电脑可以看到的目录，比如我们到目前为止一直在操作的 git_test 文件夹。与之相对的就是版本库，指当前这个多人协作的项目也就是工作区文件夹里面的 .git 文件夹，它就是当前项目的一个版本库。</p><p>版本库里面主要包含两个部分 stage 和 master，stage 就是 暂存区 ，master 是 Git 自动创建的第一个分支，master 分支拥有一个叫做 HEAD 的头指针。</p><p>结合之前的 add 和 commit 我们来分析一下 工作区 和 暂存区</p><p>首先 <code>git init</code> 之后，我们就参与到了一个协同的项目中去，你在这个文件夹下的所有文件都处于你自己的一个 工作区 中，当你在终端输入 <code>git add xxx</code> 操作之后，你的这些文件就会被同步到 .git 中的 暂存区，当你停止添加并执行 <code>git commit</code> 命令之后，Git 会将 暂存区 中的文件推到 master 分支上去，当然你也可以自行选择其他分支</p><p>这整个过程都可以在每一步完成之后只用 <code>git status</code> 来监视文件动向</p><h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>为了更好理解 Git 到底哪里好，我们可以试着去完成下面这个流程</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code> </p><p>执行结束过后我们会发现，第二次的修改并没有同步到版本库中，当前版本存的文件还是第一次修改后的样子</p><p>为什么会这样呢？那是因为 Git 跟踪并管理的是修改，而非文件。增删一行、修改字符、创建一个新文件… 这些都是对原有文件的以原有文件为基础的一个修改</p><p>所以为了确保万无一失，大家可以选择在每一个 commit 之前百分百加上一个 add</p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>首先介绍一下这个命令格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- filename</span><br></pre></td></tr></table></figure><p>这个命令的作用就是，把 filename 在工作区的修改全部撤销，这里会有两种情况：</p><ol><li>filename 修改之后还没有执行 add，也就是还没有进入暂存区，这时候撤销，就会回到和版本库一模一样的版本</li><li>filename 上一次的修改之后已经 add 进入了暂存区，在这次修改后执行 撤销，就会回到上一个版本，也就是和暂存区中的版本是一样的</li></ol><p>这时候大家觉得这个 <code>git checkout</code> 和我们刚刚学的 <code>git reset</code> 有什么区别呢，其实还是有一定区别的</p><p><code>git reset</code> 是把 暂存区 的修改撤销掉，就是和 Git 说我不提交了，你还给我，然后我就拿着 Git 还回来的版本覆盖了本地 工作区 的版本</p><p>二者的区别主要是一个文件传输方向的区别</p><blockquote><p>新版 Git 把 <code>git reset</code> 修改成了 <code>git restore</code> ，但是使用旧指令仍旧可以完成想要完成的操作</p></blockquote><p>所以为了更好的理解两种命令，我们可以列出几个场景：</p><p>场景一：我修改了工作区一个文件的内容，想直接丢弃工作区的修改，选择 <code>git checkout -- &lt;file&gt;</code></p><p>场景二：我不仅改了，我还 add 了，进了 暂存区 了，但是我想放弃这个 add，那就使用 <code>git reset HEAD &lt;file&gt;</code> ，这个时候也就是回到了场景一了，你已经在 工作区 修改完了</p><p>场景三：我 commit 都，才后悔，这个时候就需要 <code>git reset --hard HEAD^</code></p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p><p>我们选择找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>你可以选择把自己的服务器配置成可以运行 Git ，但是初学者完全可以考虑使用 Github 的 Git 仓库托管服务的功能。也就是说，要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p><strong>第1步：创建 SSH key</strong></p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>把邮箱修改自己的邮箱地址，然后一路回车顺通无阻</p><p>之后前往文件夹看一眼</p><p><img src="/2021/11/11/LearnGit/image-20211111202537485.png"></p><p>ok！get it！</p><p><strong>第2步：连接 Github</strong></p><p>登陆GitHub，打开“Account settings”，“SSH Keys”页面</p><p><img src="/2021/11/11/LearnGit/image-20211111203406525.png"></p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</p><p><img src="/2021/11/11/LearnGit/image-20211111203517790.png"></p><p>点“Add Key”，你就应该看到已经添加的Key</p><p><img src="/2021/11/11/LearnGit/image-20211111203604350.png"></p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p><img src="/2021/11/11/LearnGit/image-20211111203820464.png"></p><p>一步一步走下来就是创建好了一个 github 上面的仓库了，2：仓库名称；3：仓库介绍</p><p><img src="/2021/11/11/LearnGit/image-20211111203946085.png"></p><p>我们可以看到两种方法添加远程仓库，第一种就是你本地啥都没有，第二种是你存在一个工作区</p><p>如果从头走到现在，那么我们应该使用的是第二种方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加连接</span></span><br><span class="line">$ git remote add origin git@github.com:vychodlc/git_test.git </span><br><span class="line"><span class="comment"># 建立分支</span></span><br><span class="line">$ git branch -M main</span><br><span class="line"><span class="comment"># push!</span></span><br><span class="line">$ git push -u origin main</span><br></pre></td></tr></table></figure><p>接下来我们就可以看到非常 nice 的界面了</p><p><img src="/2021/11/11/LearnGit/image-20211111204832892.png"></p><p>接下来我们刷新刚刚建立的仓库</p><p><img src="/2021/11/11/LearnGit/image-20211111204924815.png"></p><p>ok，就是这么简单！</p><blockquote><p>接下来对刚刚命令中的一些点来多说几句：</p><ol><li>添加连接时的 <code>origin</code> 是可以随便起的名字，你也可以起自己喜欢的名字，如果添加之后想删除的话，就可以执行 <code>git remote remove &lt;name&gt;</code> </li><li>建立分支时的 <code>-M</code>  则可以实现强制修改分支的名称</li><li>推流时的 <code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code> </li><li>push 的时候可以使用 <code>git push --force origin master</code>  进行强制推送，会导致远程资源库被覆盖，这个尽量避免使用</li></ol></blockquote><h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;# git_test&quot;</span> &gt;&gt; README.md</span><br><span class="line">$ git init</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">$ git branch -M main</span><br><span class="line">$ git remote add origin git@github.com:vychodlc/git_test.git</span><br><span class="line">$ git push -u origin main</span><br></pre></td></tr></table></figure><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用 <code>git clone</code> 命令克隆。</p><p>Git支持多种协议，包括 <code>https</code> ，但 <code>ssh</code> 协议速度最快。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h4><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">创建与合并分支 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900005860592480">分支管理策略 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h4 id="Bug-分支"><a href="#Bug-分支" class="headerlink" title="Bug 分支"></a>Bug 分支</h4><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136">Bug分支 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h4 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h4><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900394246995648">Feature分支 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320">多人协作 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h4 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h4><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648">Rebase - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>现在有两个场景</p><ol><li><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p></li><li><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p></li></ol><p>大家应该都会选择第二种，那么我们就需要给每一个版本打一个标签，也就是 <code>tag</code></p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul><li><p>首先，切换到需要打标签的分支上</p></li><li><p>命令 <code>git tag &lt;tagname&gt;</code> 用于新建一个标签，默认为 <code>HEAD</code> ，也可以指定一个commit id；</p></li><li><p>命令 <code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code> 可以指定标签信息；</p></li><li><p>命令 <code>git tag</code> 可以查看所有标签。</p></li></ul><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><ul><li>命令 <code>git push origin &lt;tagname&gt;</code> 可以推送一个本地标签；</li><li>命令 <code>git push origin --tags</code> 可以推送全部未推送过的本地标签；</li><li>命令 <code>git tag -d &lt;tagname&gt;</code> 可以删除一个本地标签；</li><li>命令 <code>git push origin :refs/tags/&lt;tagname&gt;</code> 可以删除一个远程标签</li></ul><h3 id="自定义-Git"><a href="#自定义-Git" class="headerlink" title="自定义 Git"></a>自定义 Git</h3><h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><ul><li>忽略某些文件时，需要编写<code>.gitignore</code>；</li><li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li></ul><h4 id="自定义别名"><a href="#自定义别名" class="headerlink" title="自定义别名"></a>自定义别名</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>这行代码的作用执行之后，我们就可以在命令行操作的时候用 <code>git st</code> 去代替 <code>git status</code> </p><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。每个仓库的Git配置文件都放在<code>.git/config</code>文件中</p><h4 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h4><ol><li><p>安装<code>git</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure></li><li><p>创建一个<code>git</code>用户，用来运行<code>git</code>服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure></li><li><p>创建证书登录</p><p>收集所有需要登录的用户的公钥，就是他们自己的 <code>id_rsa.pub</code> 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个</p></li><li><p>初始化Git仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：</span></span><br><span class="line">$ sudo git init --bare sample.git</span><br><span class="line"><span class="comment"># Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</span></span><br><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure></li><li><p>禁用shell登录</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑 <code>/etc/passwd</code> 文件完成。找到类似下面的一行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br><span class="line"><span class="comment"># 改为：</span></span><br><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></li><li><p>克隆远程仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@server:/srv/sample.git</span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li><p><strong>管理公钥</strong>：如果团队很小，把每个人的公钥收集起来放到服务器的 <code>/home/git/.ssh/authorized_keys</code> 文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis">Gitosis</a>来管理公钥。</p></li><li><p><strong>管理权限：</strong>Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制，但是也是可以通过 钩子 去完成权限管理，可以但没有必要</p></li></ul></blockquote><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>貌似就学完了吧，这是我写的第一篇教程，其中也有很多地方是借鉴的别人的思路，虽然用了这么长时间 Git ，但是这么一整个复习下来，真的感觉整个人都通透了，很多不理解的点也变得更加清晰了</p><p>最后附上一本 Git 万能工具书，是廖雪峰老师发在他的个人网站上的。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经-0326</title>
      <link href="2021/03/26/interviewEXP-0326/"/>
      <url>2021/03/26/interviewEXP-0326/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="公司名称：忘记了呃呃呃"><a href="#公司名称：忘记了呃呃呃" class="headerlink" title="公司名称：忘记了呃呃呃"></a>公司名称：忘记了呃呃呃</h3><h4 id="面试形式：电话面试"><a href="#面试形式：电话面试" class="headerlink" title="面试形式：电话面试"></a>面试形式：电话面试</h4><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><ol><li><p>介绍自己</p><blockquote><p>abaabaaba…….</p></blockquote></li><li><p>怎么学习前端的</p><blockquote><p>js用红宝书、css用案例、vue用网课和项目、代码能力用leetcode</p></blockquote></li><li><p>介绍css学习样例</p><blockquote><p>介绍了 swiper 以及 伪类</p></blockquote></li><li><p>vue的双向绑定</p><blockquote><p>介绍 MVVM 的原型 MVC，Model 和 View 在 MVVM 中是通过 VM(ViewModel) 来进行数据相互控制的，如果在某一边数据发生了改变，那么监听数据的 VM 也就是向另一边发出修改指定数据的命令，从而实现数据绑定</p></blockquote></li><li><p>如何实现 button 点击的涟漪特效</p><blockquote><p>使用伪类，伪类的大小、颜色(rgba)使用 js 来控制。当 button 的 click 事件发生后，涟漪特效函数会触发，动态修改伪类的大小(越来越大)，rgba 的 <code>a</code> 值，越来越透明，达到一种扩散最终消失的特效</p></blockquote></li><li><p>描述一道有意思的算法题</p><blockquote><p>最大回文子串 —-&gt; 使用对称扩散法，由于回文一定是对称的，所以只要从某一字符串元素向左右扩散，就可以得到以该元素为中心的最大回文子串并存储到回文子串数组中。最终遍历一次数组获得最大长度并且输出。</p></blockquote></li><li><p>我对于自己职业的规划</p><blockquote><p>不知道怎么回答，只是说了说自己眼中的前端的发展前景：多端开发、云函数、小程序</p></blockquote></li><li><p>有什么想问的</p><blockquote><p>balabalabalabalabalabalabalabalabalabala……</p></blockquote></li></ol><hr><h3 id="公司名称：博乐科技"><a href="#公司名称：博乐科技" class="headerlink" title="公司名称：博乐科技"></a>公司名称：博乐科技</h3><h4 id="面试形式：在线笔试"><a href="#面试形式：在线笔试" class="headerlink" title="面试形式：在线笔试"></a>面试形式：在线笔试</h4><h4 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h4><ol><li><p>单选题： css 可以让元素不显示的方法</p><blockquote><p>overflow: hidden<br>opacity: 0<br>display: none</p></blockquote></li><li><p>多选题：css 选择器的优先级</p><blockquote><p>important &gt; 内联 &gt; id &gt; class &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符</p></blockquote></li><li><p>编程题：</p><blockquote><p><strong>leetcode</strong> 进制转换（<code>while</code>循环直至除净）</p></blockquote></li></ol><p>  <strong>leetcode</strong> 两天之间隔着那些天（使用<code>Date</code>对象转换成毫秒再转换成字符串）<br>  <strong>leetcode</strong> 最长回文子串（对称扩散法）<br>  <strong>leetcode</strong> 字符串处理——无限循环小数（寻找循环节进行处理）</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Hot 100 - 3.无重复字符的最长子串</title>
      <link href="2021/03/26/leetcodeHot100-3/"/>
      <url>2021/03/26/leetcodeHot100-3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述-中等"><a href="#题目描述-中等" class="headerlink" title="题目描述(中等)"></a>题目描述(中等)</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">原题链接</a></p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入：</strong>s = “abcabcbb”<br><strong>输出：</strong>3<br><strong>解释：</strong>因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p><strong>输入：</strong>s = “bbbbb”<br><strong>输出：</strong>1<br><strong>解释：</strong>因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p><strong>输入：</strong>s = “pwwkew”<br><strong>输出：</strong>3<br><strong>解释：</strong>因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 $r_k$<br>​<br>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；</p><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p><p>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 <code>C++</code> 中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code>, <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i]+nums[j]==target&amp;&amp;i!=j) &#123;</span><br><span class="line">        <span class="keyword">return</span> [i,j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><ul><li><p>时间复杂度：O(N)O(N)，其中 NN 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p></li><li><p>空间复杂度：O(|\Sigma|)O(∣Σ∣)，其中 \SigmaΣ 表示字符集（即字符串中可以出现的字符），|\Sigma|∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即 |\Sigma| = 128∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 |\Sigma|∣Σ∣ 个，因此空间复杂度为 O(|\Sigma|)O(∣Σ∣)。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> hot-100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Hot 100 - 2.两数相加</title>
      <link href="2021/03/25/leetcodeHot100-2/"/>
      <url>2021/03/25/leetcodeHot100-2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述-中等"><a href="#题目描述-中等" class="headerlink" title="题目描述(中等)"></a>题目描述(中等)</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">原题链接</a></p><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]<br><strong>输出：</strong>[7,0,8]<br><strong>解释：</strong>342 + 465 = 807.</p><p><strong>输入：</strong>l1 = [0], l2 = [0]<br><strong>输出：</strong>[0]</p><p><strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br><strong>输出：</strong>[8,9,9,9,0,0,0,1]</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>将两个数组分别转换为两个十进制的数字，进行加减之后，将和再转换成数组形式</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始量定义</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">new</span> ListNode(<span class="string">&#x27;head&#x27;</span>);      <span class="comment">// 定义结点</span></span><br><span class="line">  <span class="keyword">let</span> temp = node;                      <span class="comment">// 哑结点</span></span><br><span class="line">  <span class="keyword">let</span> add = <span class="number">0</span>;                          <span class="comment">// 进位位，1有效</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;                          <span class="comment">// 新链表当前未取余的值 = 链表1值 + 链表2值 + add（来自上一级）;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历，直到最长的都为空</span></span><br><span class="line">  <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">    sum = (l1 ? l1.val : <span class="number">0</span>) + (l2 ? l2.val : <span class="number">0</span>) + add;  <span class="comment">// 三元表达式，sum 定义式</span></span><br><span class="line">    temp.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);                 <span class="comment">// 取余作为新链表的值</span></span><br><span class="line">    temp = temp.next;                         <span class="comment">// 当前结点后移一位</span></span><br><span class="line">    add = sum &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;                  <span class="comment">// 判断是否需要进位</span></span><br><span class="line">    l1 &amp;&amp; (l1 = l1.next);                     <span class="comment">// 若 l1 不为空就往后移</span></span><br><span class="line">    l2 &amp;&amp; (l2 = l2.next);                     <span class="comment">// 若 l2 不为空就往后移</span></span><br><span class="line">  &#125;</span><br><span class="line">  add &amp;&amp; (temp.next = <span class="keyword">new</span> ListNode(add));       <span class="comment">// 最后一位进位的话直接赋值为一</span></span><br><span class="line">  <span class="keyword">return</span> node.next;                             <span class="comment">// 由于node是头节点为空，所以返回第一个结点作为链表地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> hot-100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Hot 100 - 1.两数之和</title>
      <link href="2021/03/24/leetcodeHot100-1/"/>
      <url>2021/03/24/leetcodeHot100-1/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述-简单"><a href="#题目描述-简单" class="headerlink" title="题目描述(简单)"></a>题目描述(简单)</h1><p><a href="https://leetcode-cn.com/problems/two-sum/">原题链接</a></p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>输入：</strong>nums = [2,7,11,15], target = 9<br><strong>输出：</strong>[0,1]<br><strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><p><strong>输入：</strong>nums = [3,2,4], target = 6<br><strong>输出：</strong>[1,2]</p><p><strong>输入：</strong>nums = [3,3], target = 6<br><strong>输出：</strong>[0,1]</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h3 id="1-暴力解决"><a href="#1-暴力解决" class="headerlink" title="1.暴力解决"></a>1.暴力解决</h3><p>双重<code>for</code>循环遍历</p><p>时间复杂度 $\mathcal{O}(n^2)$</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i]+nums[j]==target&amp;&amp;i!=j) &#123;</span><br><span class="line">        <span class="keyword">return</span> [i,j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-暴力-优化（减少访问次数）"><a href="#2-暴力-优化（减少访问次数）" class="headerlink" title="2.暴力-优化（减少访问次数）"></a>2.暴力-优化（减少访问次数）</h3><p>双重<code>for</code>循环遍历，修改j的起点</p><p>时间复杂度 $\mathcal{O}(n^2)$</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;len;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i]+nums[j]==target) &#123;</span><br><span class="line">        <span class="keyword">return</span> [i,j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3.哈希表"></a>3.哈希表</h3><p>遍历的同时，记录一些信息，省去一层循环，（以空间换时间）</p><p>需要记录已经遍历过的数值和它对应的下标，借助查表实现</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">const</span> MAP = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  MAP.set(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> other = target - nums[i];</span><br><span class="line">    <span class="keyword">if</span> (MAP.get(other) !== <span class="literal">undefined</span>) <span class="keyword">return</span> [MAP.get(other), i];</span><br><span class="line">    MAP.set(nums[i], i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> hot-100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计-论文翻译</title>
      <link href="2021/02/24/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
      <url>2021/02/24/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h3 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h3><p><a href="https://ieeexplore.ieee.org/document/9113407">Machine Learning Enabling Analog Beam Selection for Concurrent Transmissions in Millimeter-Wave V2V Communications</a></p><h3 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h3><p>在毫米波 V2V 通信中实现并发传输的机器学习启用模拟波束选择</p><blockquote><p><strong>毫米波：</strong><br>毫米波移动通信存在传输距离短、穿透和绕射能力差、容易受气候环境影响等缺点。因此，打造出具有高增益、有自适应波束形成和波束控制能力的天线阵列，成为毫米波天线设计的首要任务，此外，由于毫米波的传输距离短，要达到良好的覆盖效果，必须用大量的毫米波天线实现覆盖</p></blockquote><h3 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0.摘要"></a>0.摘要</h3><p>随着毫米波 （mmWave） 技术和车辆对车辆 （V2V） 通信的发展，预计毫米波车辆专用网络 （VANETs） 将支持快速增长的车辆数量。在此背景下，预计每个 V2V 用户 （VUE） 将采用<strong>大规模阵列</strong>来形成<strong>定向模拟波束</strong>，以改进<strong>空间频谱重用</strong>，并能够同时实现来自多个其他 VUE 的并发传输。但是，由于 V2V 链路的高动态性，每个 VUE 快速选择有效的模拟光束可能具有挑战性。在本文中，我们提出了一种机器学习 （ML） 方法，以实现 mmWave V2V 通信高效、快速的模拟波束选择。具体来说，我们首先推导出多个 V2V 发射器 （TX） 为一个 VUE 提供服务以获得 mmWave V2V 通信的平均总和率 （ASR）。在此基础上，我们开发了一种 ML 方法，以最大限度地提高 ASR，从而将支持矢量机 （SVM） 分类器用于优化模拟光束选择。此外，我们还提出了迭代顺序最小优化培训算法，以训练所有 V2V 链路的数据样本，并讨论了建议解决方案的趋同性。最后，使用谷歌TensorFlow对广泛的样本培训和模拟进行了评估。结果证明，我们建议的 ML 方法能够实现更高的 ASR，但计算复杂性远低于基于明确估计的渠道的传统解决方案。</p><p><strong>Index Tearms：</strong>机器学习、毫米波车辆专用网络、并发传输、模拟波束选择、支持向量机</p><blockquote><p><strong>背景：</strong><br><code>V2X</code> ，即 Vehicle to Everything<br><code>V2V</code>（虚拟机到虚拟机的迁移，Virtual to Virtual），又称虚拟机的克隆。<br><code>V2R</code>（车辆与路侧单元，vehicle to roadside unit）<br><code>V2I</code>（车与道路基础设施通信）</p><p>mmWave + V2V = <code>VANETs</code></p><p><strong>建模：</strong><br>多个 V2V 发射器 （TX） 为一个 VUE 提供服务</p><p><strong>机器学习:</strong></p><ol><li>实现 mmWave V2V 通信高效、快速的模拟波束选择<ol><li>推导出ASR</li><li>ML方法最大限度提高ASR</li><li>SVM分类器优化模拟波束选择</li></ol></li><li>迭代顺序最小优化培训算法<ol><li>训练所有V2V链路的数据样本</li><li>趋同性</li></ol></li></ol></blockquote><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>毫米波（mmWave）的车对车（V2V）通信在未来的车辆自组织网络（VANET）中扮演着重要的角色。 随着车辆的车载单元（OBU）不断增加，支持数千个连接以提供各种本地服务，例如高清晰度（HD）地图，自动驾驶等。 因此，对更大带宽和更高传输速率的需求触发了毫米波V2V通信的发展。 通过利用VANET中的mmWave大型阵列来提高空间频谱效率，<strong>多个V2V用户（VUE）可以实现与同一目标VUE对齐的定向模拟波束</strong>，以同时提供并发传输。 在此，短距离V2V通信可以大大减少mmWave传输的路径损耗</p><p>mmWave V2V通信的并发传输在先前的工作中已经作为重要问题进行了研究[3]，[4]。 这些方案基于<strong>VUE发射机（TX）选择合适的模拟波束为目标VUE发射信号的传统方法</strong>。 在[3]中，为了保证毫米波通信的鲁棒性，提出了<strong>一种具有波束跟踪和自愈功能的波束管理方法</strong>。 文献[4]通过组合预编码矩阵以最大化下行链路传输速率来扩展波束选择。 但是，这些方法通常会评估所有可能的光束，并且会花费很高的计算复杂度。 尤其是当VANET中分布有大量VUE时，使用这些传统方法来提高性能（例如系统鲁棒性[3]，频谱效率[5]等）变得越来越困难。</p><blockquote><p><strong>鲁棒性：</strong>健壮和强壮的意思。它也是在异常和危险情况下系统生存的能力</p></blockquote><p>幸运的是，作为最热门的人工智能（AI）技术之一，机器学习（ML）或深度学习（DL）显示了一种非常有前途的提高无线通信性能的方法[6]。<strong>通过训练网络的历史数据，可以提取系统功能以改善通信性能</strong>，例如智能调制[7]，智能波束管理[8]等。 借助这些AI技术，<strong>可以有效缓解高复杂度和高延迟的问题</strong>，这显示了非常有前途的应用前景。</p><p>因此，在本文中，我们的研究工作提出了一种新的基于ML的毫米波V2V通信中并发传输方法，其中提出了一种低复杂度和有效的模拟波束选择方法。特别是，<strong>通过使用异构泊松点过程（HPPP）的随机分布对大量VUE建模</strong>[9]，我们得出了并发传输下V2V通信的平均总速率（ASR）。此外，将VANET中的所有V2V链接作为用于ML训练的大型数据库进行采样，此外，针对每个VUE的模拟波束选择，提出了一个迭代的一对一（1v1）支持向量机（SVM）分类器。此外，我们设计了一种迭代顺序最小优化（SMO）训练算法，其中VUE发射机（TX）可以在并发传输期间实现高效且低复杂度的模拟波束选择。最后，Google TensorFlow用于ML训练和网络仿真。结果证明，我们提出的算法非常接近理论性能边界，同时大大降低了计算复杂度。我们还证明，与传统的基于信道估计的方法相比，我们提出的算法可以实现更高的并发传输ASR。</p><p>在本文的其余部分，第二部分介绍了mmWave V2V通信的系统模型。 第三节推导了并发传输的ASR。 在第四部分，我们分析了提出的迭代1v1 SVM分类器，并设计了SMO训练算法。 最后，在第五部分讨论了仿真结果，第六部分总结了本文。</p><h3 id="2-系统模型"><a href="#2-系统模型" class="headerlink" title="2.系统模型"></a>2.系统模型</h3><p>我们将毫米波VANET模型建模为均一的泊松点过程（HPPP）$\Pi_V$，其二维平面ℜ上的V2V链路密度为$\lambda_V$。 V2V链接是一对VUE TX和VUE RX(发射器与接收器)之间的通信链接，其中该V2V链接建立在毫米波频率[10]上。因此，V2V链接密度表示单位面积中V2V链接的平均数量。 VUE的所有OBU都支持mmWave大规模MIMO用于V2V通信，其中天线编号表示为$N_{OBU}$。借助<strong>波束成形</strong>技术，天线之前的每个射频（RF）链都有一系列的移相器，可以在其中形成模拟波束并将其定向到目标VUE。如图1所示，每个VUE可以形成一个定向波束以将信号传输到另一个VUE，这样多个VUE可以实现与同一目标VUE对齐的定向模拟波束，以同时提供并发传输[10]。如果由OBU执行信道估计，则可以知道每个V2V链路的CSI。根据Slivnyak的理论[9]，定义了原始VUE的典型RX，它不会影响HPPP的统计属性。将$R$表示为最大通信距离，可以将<strong>接收器周围的平均VUE发送器</strong>（TX）写为<br>$$<br>N_V=\lfloor\lambda_V\pi R^2\rfloor\tag{1}<br>$$<br>其中⌊.⌋是实用的 VANET 的向下取整功能。将第 $k$ 个V2V 链接数据流定义为 $d_{V,k},(1 ≤ k ≤ N_V)$，将 VUE 的第$k$个TX 功率定义为 $P_{V,k}$。<strong>VUE TX 的信号</strong>可以写成<br>$$<br>\mathbf{s}<em>{V,k}=\mathbf{c}</em>{V,k}d_{V,k}\tag{2}<br>$$<br>其中 $\mathbf{c}<em>{V,k}\in \mathbb{C}^{N</em>{OBU}\times1}$ 是第$k$个VUE的模拟波束，它使用相移器来定向指向接收器。毫米波通道传播基于扩展的萨利赫-瓦伦祖德拉模型 [4]，该模型定义为如下的<strong>窄频段聚类通道模型</strong>：<br>$$<br>\mathbf{H}<em>{V,k}=\gamma\sum</em>{l=1}^L\alpha_{V,k,l}\pmb{\alpha}<em>{RV}(\phi</em>{RV,k,l})[\pmb{\alpha}<em>{V,k}(\phi</em>{V,k,l})]^H\tag{3}<br>$$<br>其中 $\gamma=\frac{N_{OBU}}{\sqrt{L}}$，$L$ 是传播路径的数量，$\alpha_{V,k,l}$ 是第 $l$ 条路径的复杂增益，$\alpha_{V,k,l}\sim\mathcal{CN}(0,1)$。$\mathbf{H}<em>{V,k}$ 满足 $|\mathbf{H}</em>{V,k}|<em>F^2=N</em>{OBU}^2$，其中 $|.|<em>F$ 是矩阵的弗罗贝纽斯规范。$\pmb{\alpha}</em>{RV}(\phi_{RV,k,l})$ 和 $\pmb{\alpha}<em>{V,k}(\phi</em>{V,k,l})$ 分别是每个V2V链路中RX和TX的天线阵列响应。$\phi_{RV,l}$ 和 $\phi_{V,l}$ 是与RX和TX之间的第 $l$ 条路径相关的 AoA 和 AoD 的方位角。我们假设所有OBU都沿y轴部署统一线性阵列（ULA）的天线。因此，<strong>阵列转向向量</strong> $\pmb{\alpha}<em>{RV}(\phi</em>{RV,k,l})$ 和 $\pmb{\alpha}<em>{V,k}(\phi</em>{V,k,l})$ 可以被写作：<br>$$<br>\pmb{\alpha}<em>{RV}(\phi</em>{RV,k,l})=\frac{[1,e^{j\sigma D_{RV}\sin(\phi_{RV,k,l})},…,e^{j\sigma D_{RV}(N_{OBU}-1)\sin(\phi_{RV,k,l})}]^T}{\sqrt{N_{OBU}}}\tag{4}<br>$$</p><p>$$<br>\pmb{\alpha}<em>{V}(\phi</em>{V,k,l})=\frac{[1,e^{j\sigma D_{V}\sin(\phi_{V,k,l})},…,e^{j\sigma D_{V}(N_{OBU}-1)\sin(\phi_{V,k,l})}]^T}{\sqrt{N_{OBU}}}\tag{5}<br>$$</p><p>其中 $\sigma=\frac{2\pi}{\lambda}$ ，$\lambda$ 是该信号波长，$D_{RV}$ 和 $D_{V}$ 分别是RX和TX中两个相邻的ULA元素的间距。然后，<strong>接收信号</strong>可以被表示为：<br>$$<br>\mathbf{y}<em>{RV}=\mathbf{g}</em>{RV}\sum_{k=1}^{N_V}\mathbf{H}<em>{V,k}\mathbf{c}</em>{V,k}d_{V,k}+\mathbf{g}<em>{RV}\mathbf{n}\=\mathbf{g}</em>{RV}[\mathbf{H}<em>{V,1}\mathbf{c}</em>{V,1},…,\mathbf{H}<em>{V,N_V}\mathbf{c}</em>{V,N_V}]\left[<br>\begin{matrix}d_{V,k}\\vdots\d_{V,N_V}\\end{matrix}\right]+\mathbf{g}<em>{RV}\mathbf{n}\tag{6}<br>$$<br>其中 $\mathbf{g}</em>{RV}=\left[\begin{matrix}g_{RV,1}&amp;\cdots&amp;0\\vdots&amp;\ddots&amp;\vdots\0&amp;\cdots&amp;g_{RV,N_{OBU}}\\end{matrix}\right]$，此矩阵中的每个对角线元素表示接收天线的相移器值。然后<strong>用迫零接收机(ZF)将该信号转变</strong>为<br>$$<br>\mathbf{y}<em>{RV,ZF}=[d</em>{V,1},\cdots,d_{V,N_V}]^T+(\mathbf{G}^H\mathbf{G})^{-1}\mathbf{G}^H\mathbf{g}<em>{RV}\mathbf{n}<br>\tag{7}<br>$$<br>其中 $\mathbf{G}=\mathbf{g}</em>{RV}[\mathbf{H}<em>{V,1}\mathbf{c}</em>{V,1},\cdots,\mathbf{H}<em>{V,N_V}\mathbf{c}</em>{V,N_V}]$。</p><p>在V2V通信中，所有VUE发射机根据预先定义的码本选择候选矢量，形成定向模拟波束，预先定义的码本为 $\mathcal{C}={\mathbf{c}_V^1,\mathbf{c}_V^2,\cdots,\mathbf{c}_V^{V_C}}$，其中 $\mathbf{c}<em>V^i\in \mathbb{C}^{N</em>{OBU}\times1},i=1,2,\cdots,N_C,(N_C\gt2)$，$N_C$ 是候选矢量的个数。</p><h3 id="3-并发传输的ASR-平均总传输速率"><a href="#3-并发传输的ASR-平均总传输速率" class="headerlink" title="3.并发传输的ASR(平均总传输速率)"></a>3.并发传输的ASR(平均总传输速率)</h3><p>在文献7中，噪声功率满足<br>$$<br>E[(\mathbf{G}^H\mathbf{G})^{-1}\mathbf{G}^H\mathbf{g}_{RV}\mathbf{n}]=\delta^2(\mathbf{G}^H\mathbf{G})^{-1}<br>\tag{8}<br>$$</p><p>这里的 $$\delta^2$$ 是高斯白噪声的方差。对于第 $$k$$ 个V2V链路，其传输速率满足<br>$$<br>R_{k}=\log <em>{2}\left(1+\frac{P</em>{\mathrm{V}, k}\left|\mathbf{H}<em>{\mathrm{V}, k} \mathbf{c}</em>{\mathrm{V}, k}\right|^{2}}{N_{\mathrm{OBU}} \sigma^{2}}\right)<br>\tag{9}<br>$$<br>因为总共存在 $\tau$ 个V2V链路，所以所有的传输速率满足<br>$$<br>R_{\tau}=\sum_{k=1}^\tau\log <em>{2}\left(1+\frac{P</em>{\mathrm{V}, k}\left|\mathbf{H}<em>{\mathrm{V}, k} \mathbf{c}</em>{\mathrm{V}, k}\right|^{2}}{N_{\mathrm{OBU}} \sigma^{2}}\right), \quad(\tau=1,2,3…)<br>\tag{10}<br>$$<br>根据HPPP(异构泊松点过程)和泊松分布，我们可以知道对于每一个 $\tau$ ，在典型RX周围r半径范围内的VUE数的概率函数为<br>$$<br>\operatorname{Pr}<em>{V}\left(N</em>{\mathrm{V}}=\tau\right)=\frac{\left(\lambda_{\mathrm{V}} \pi R^{2}\right)^{\tau}}{\tau !} e^{-\lambda \mathrm{v} \pi R^{2}}, \quad(\tau=1,2,3 \ldots)\tag{11}<br>$$<br>因此，ASR度量被定义为一个平均值，即在所有可能的 $\tau$ ( $\tau$ 从1到无穷) 下的传输速率期望，满足<br>$$<br>\text { ASR }<em>{\mathrm{RV}}<br>=\lim\limits <em>{\tau \rightarrow \infty} \sum</em>{k=1}^\tau\left[\frac{\left(\lambda</em>{\mathrm{V}} \pi R^{2}\right)^{\tau}}{\tau !} e^{-\lambda_{\mathrm{V}} \pi R^{2}}\right] \log <em>{2}\left(1+\frac{P</em>{\mathrm{V}, k}\left|\mathbf{H}<em>{\mathrm{V}, k} \mathbf{c}</em>{\mathrm{V}, k}\right|^{2}}{N_{\mathrm{OBU}} \sigma^{2}}\right)\tag{12}<br>$$</p><p>这里的 $\mathrm{SNR}<em>{\mathrm{V}, k}=P</em>{\mathrm{V}, k}\left|\mathbf{H}<em>{\mathrm{V}, k} \mathbf{c}</em>{\mathrm{V}, k}\right|^{2} /\left(N_{\mathrm{OBU}} \sigma^{2}\right)$ 是来自所有 VUE 的并发传输的信噪比。</p><p>基于上述评估指标，我们进一步使用 SVM 来提高 V2V 通信的性能。SVM 是一种典型的受监督的 ML 算法，培训数据由超过 512 个 HPPP 快照生成。在每个快照中，至少有 10 个 VUE TX 随机分布在网络中。每个 VUE TX 及其目标 VUE RX 都会形成 V2V 链接。网络动态更改。因此，VUEs 位于不同位置时有不同快照，这可能会导致参数的变化，如路径损耗、功率、AoA 和 AoD 的方位角等。这些值可以被收集来用于生成 ML 训练的数据样本。</p><h3 id="4-迭代1v1-SVM-分类器"><a href="#4-迭代1v1-SVM-分类器" class="headerlink" title="4.迭代1v1 SVM 分类器"></a>4.迭代1v1 SVM 分类器</h3><h4 id="A-V2V-通信的-ML-培训样本"><a href="#A-V2V-通信的-ML-培训样本" class="headerlink" title="A. V2V 通信的 ML 培训样本"></a>A. V2V 通信的 ML 培训样本</h4><p>对于每一个 V2V 链路，VUE 需要从 C 中的 $N_C$ 候选向量中选取一个模拟波束。所以，我们提出一个1v1 SVM 分类器用来波束选择。每一个用来ML训练的数据样本都是基于 $L$ 传播路径。因此，会有 $2+4L$ 个随机真值作为样本元素，其中包括发送端功率、路径损耗、$2L$ 个AoA和AoD的方位角、$2L$ 个复杂增益的实部和虚部。由于样本中不同的元素在不同的取值范围内被选取，因此对数据集进行了归一化预处理。训练数据中的每一个样本都是一个 $2+4L$ 的向量 $\mathbf{x}<em>{j}, j \in{1,2, \ldots, J}$ ，其中的 $J$ 是样本数。每一个数据样本都映射向它自己的最优模拟波束 $\mathbf{c}^{i *}$, $i* \in{1,2, \ldots, N_\mathcal{C}}$，即如果 $\mathbf{c}^{i *}$ 被选择了，那么 $\mathrm{SNR}</em>{\mathrm{V}, k}$ 可以达到一个最大值。因此，将样本分类为成 $N_{\mathcal{C}}$ 个类进行 ML 训练。例如，第 $j$ 个样本是 $\mathbf{x}_{j}$ ，在 $C$ 中被归类为一种模拟波束。 一旦 V2V 链路发生变化，本文提出的 SVM 分类器可以预测模拟波束，在任意两个不同的训练样本之间生成一个分离超平面。此外，由于数据集不平衡，属于某一种样本的数量可能会比其他样本少得多，这给最终结果带来很大的偏差，导致预测不准确。因此，SVM 分类器应该以 “1v1” 的方式进行迭代训练。</p><blockquote><p><strong>L propagation paths:</strong> ?<br><strong>$N_{\mathcal{C}}$:</strong> ?  </p></blockquote><h4 id="B-用于-ML-培训的迭代-SMO-算法"><a href="#B-用于-ML-培训的迭代-SMO-算法" class="headerlink" title="B. 用于 ML 培训的迭代 SMO 算法"></a>B. 用于 ML 培训的迭代 SMO 算法</h4><p>1v1 SVM分类器基于 $\mathcal{C}$ 的子集 $\mathbf{U}$，该子集只包含两种模拟波束。每次分类后，从C中提取一个新的候选向量来替换这两种向量中的一种。然后，我们根据更新后的 $\mathbf{U}$ 来继续训练。SMO 算法用来迭代一直到 $N_{\mathcal{C}}-1$ 个候选向量被选中，具体情况如下：</p><p>假设在一次迭代中，子集 $\mathbf{U}=\left{\mathbf{c}<em>{\mathrm{V}}^{1}, \mathbf{c}</em>{\mathrm{V}}^{2}\right} \subset \mathcal{C}$。我们将属于 $\mathbf{c}<em>{\mathrm{V}}^{1}$ 的训练样本标记为 -1，属于 $\mathbf{c}</em>{\mathrm{V}}^{2}$ 的训练样本标记为 1。这样便有：<br>$$<br>\begin{array}{cc}<br>\min &amp; \frac{1}{2}|\mathbf{w}|^{2}+C \sum\limits_{j=1}^{J} \xi_{j} \<br>\text { s.t. } &amp; y_{j}\left[\mathbf{w}^{T} \phi\left(\mathbf{x}<em>{j}\right)+b\right] \geq 1-\xi</em>{j} \quad(j \in{1,2, \ldots, J}),\quad \xi_{j} \geq 0<br>\end{array}\tag{13}<br>$$<br>这里的 $\mathbf{w}$ 是分离超平面系数的向量，$\phi\left(·\right)$ 为 $\mathbf{x}<em>{j}$ 到变换后的特征空间的映射，$y</em>{j}$ 为类标号，$b$ 为超平面公式的常偏置。由于样本噪声的影响，我们使用了松弛变量，它是特征点 $\xi_{j} \geq 0$ 时函数边界的容许值。权值 $C$ 控制支持向量和超平面之间的边界。根据Karush-Kuhn-Tucker条件，得到原问题的拉格朗日函数为：<br>$$<br>\mathcal{L}\left(\mathbf{w}, b, \xi_{j}, a_{j}, \beta_{j}\right)=\frac{1}{2}|\mathbf{w}|^{2}+C \sum_{j=1}^{J} \xi_{j}<br>-\sum_{j=1}^{J} a_{j}\left{y_{j}\left[\mathbf{w}^{T} \mathbf{x}<em>{j}+b\right]-1+\xi</em>{j}\right}-\sum_{j=1}^{J} \beta_{j} \xi_{j}\tag{14}<br>$$<br>这里的拉格朗日乘子 $a_{j} \geq 0, \beta_{j} \geq 0, j=1,2, \ldots, J$，这里的核函数 $\phi\left(·\right)$ 是线性核函数。</p><p>分别对上式的 $\mathbf{w}$ ，$b$，和 $\xi_{j}$ 求偏导，将结果返回 $\mathcal{L}\left(\mathbf{w}, b, \xi_{j}, a_{j}, \beta_{j}\right)$。那么，<strong>SVM特征的输出函数</strong>为：<br>$$<br>\mu_{j}=\sum_{j=1}^{J} a_{j} y_{j} \mathbf{x}<em>{j}^{T} \mathbf{x}</em>{j}+b, \quad j=1,2, \ldots, J\tag{15}<br>$$<br>考虑（15）和异常值，我们得到如下的 $a_{j}$ ：</p><ul><li>当 $a_{j} = 0$ 时，样本属于某一候选码字，<strong>位于支撑平面一侧</strong>，有 $y_{i} \mu_{j} \geq 1$。</li><li>当 $0&lt;a_{j}&lt;C$ 时，样本是支持向量，<strong>位于支撑平面上</strong>，有 $y_{i} \mu_{j} = 1$。</li><li>当 $a_{j}=C$ 时，支持向量<strong>位于分离的超平面和支持平面之间</strong>，有 $y_{i} \mu_{j} \leq 1$。</li></ul><p>$a_{j}$ 同时也满足 $\sum\limits_{j=1}^{J} a_{j} y_{j}=0$ ，当这三个条件未建立时，我们需要同时更新两个 $a_j$ 值。假设我们更新  $a_{j1}$ 和 $a_{j2}$，$j_{1} \neq j_{2}, j_{1}, j_{2} \in{1,2,\dots,J}$ 。我们有：<br>$$<br>a_{j_{1}}^{ {new }} y_{1}+a_{j_{2}}^{ {new }} y_{2}=a_{j_{1}}^{ {old }} y_{1}+a_{j_{2}}^{ {old }} y_{2}=\rho\tag{16}<br>$$<br>这里的下标“new”和“old”表示更新前后的值，而 $\rho$ 则是常数。定义 $a_{j_{2}}^{\text {new }} \in\left[a_{L}, a_{H}\right]$ ，设置 $\Xi={1,2, \ldots, J} \backslash\left{j_{1}, j_{2}\right}$ ，可以得到：</p><ul><li>当 $y_{1} y_{2}&lt;0, a_{j_{1}}^-a_{j_{2}}^=\rho$，那么 $a_{L}=\max (0,-\rho)$，$a_{H}=\min (C, \rho- C)$。</li><li>当 $y_{1} y_{2}&gt;0, a_{j_{1}}^+a_{j_{2}}^=\rho$，那么 $a_{L}=\max (0,\rho- C)$，$a_{H}=\min (C, \rho)$。</li></ul><p>从 $\sum\limits_{j=1}^{J} a_{j} y_{j}=0$ 中我们可以知道，$a_{j_{1}} y_{j_{1}}=a_{j_{2}} y_{j_{2}}+\sum\limits_{j \in \Xi} a_{j} y_{j}$。此外，同时在等式两边乘以 $y_{j_{1}}$，有 $a_{j1}=-ta_{j2}+A$，其中的 $t=y_{j1}y_{j2}，A=y_{j_{1}} \sum\limits_{j \in \Xi} a_{j} y_{j}$。</p><p>定义 $v_{j_{1}}=\sum_{j \in \Xi} a_{j} y_{j} \mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j}, v</em>{j_{2}}=\sum_{j \in \Xi} a_{j} y_{j} \mathbf{x}<em>{j</em>{2}}^{\mathrm{T}} \mathbf{x}<em>{j}$，目标函数改编成：<br>$$<br>f\left(a</em>{j_{1}}, a_{j_{2}}\right)=a_{j_{1}}+a_{j_{2}}-\frac{1}{2} a_{j_{1}}^{2} \mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{1}}-\frac{1}{2} a_{j_{2}}^{2} \mathbf{x}<em>{j</em>{2}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{2}} \<br>-y_{j_{1}} y_{j_{2}} a_{j_{1}} a_{j_{2}} \mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{2}}-y_{j_{1}} a_{j_{1}} v_{j_{1}}-y_{j_{2}} a_{j_{2}} v_{j_{2}}+D<br>\tag{17}<br>$$</p><p>这里的 $D$ 代表除了 $a_{j1}$ 和 $a_{j2}$ 以外的所有元素。根据 $\frac{\partial f}{\partial a_{j_{2}}}=0$，得到新的 $a_{j2}$ 为：<br>$$<br>a_{j_{2}}^{ {new } \prime}=\frac{\left(-y_{j_{1}}+y_{j_{2}}+v_{j_{1}}-v_{j_{2}}-y_{j_{1}} A \mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{2}}+y_{j_{1}} A \mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{1}}\right) y_{j_{2}}}{\mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{1}}+\mathbf{x}<em>{j</em>{2}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{2}}-2 \mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{2}}}\tag{18}<br>$$<br>由于 $j_{1} \neq j_{2}, j_{1}, j_{2} \in{1,2, \ldots, J}$，我们可以知道 $\mu_{j_{2}}=\mathbf{w}^{T} \mathbf{x}<em>{j</em>{2}}+b$，令 $E_{j_{i}}=\mu_{j_{i}}-y_{j_{i}}, (i=1,2)$，$\zeta=\mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{1}}+\mathbf{x}<em>{j</em>{2}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{2}}-2 \mathbf{x}<em>{j</em>{1}}^{\mathrm{T}} \mathbf{x}<em>{j</em>{2}}$。那么，我们有：<br>$$<br>a_{j_{2}}^{\text {new } \prime}=a_{j_{2}}^{\text {old }}+\left(y_{j_{2}} / \zeta\right)\left(E_{j_{1}}-E_{j_{2}}\right)\tag{19}<br>$$<br>此外，结合 $0&lt;a_{j}&lt;C$ 的约束条件，我们可以得到：<br>$$<br>a_{j_{2}}^{ {new }}=\left{\begin{array}{cc}a_{H} &amp; a_{j_{2}}^{ {new }\prime} &lt; \alpha_{L} \a_{j_{2}}^{ {new }\prime} &amp; a_{L} \leq a_{j_{2}}^{ {new }\prime} \leq a_{H} \a_{L} &amp; a_{j_{2}}^{ {new }\prime}&gt;a_{H}\end{array}\right.\tag{20}<br>$$<br>根据式（16），我们可以把 $a_{j_{1}}^{\text {new }}$ 更新为：<br>$$<br>a_{j_{1}}^{ {new }}=a_{j_{1}}^{o l d}+y_{j_{1}} y_{j_{2}}\left(a_{j_{2}}^{ {old }}-a_{j_{2}}^{ {new }}\right)\tag{21}<br>$$</p><blockquote><p><strong>Karush-Kuhn-Tucker条件:</strong> ?</p></blockquote><h4 id="C-用于-1v1-SVM-培训的迭代-SMO-算法"><a href="#C-用于-1v1-SVM-培训的迭代-SMO-算法" class="headerlink" title="C. 用于 1v1 SVM 培训的迭代 SMO 算法"></a>C. 用于 1v1 SVM 培训的迭代 SMO 算法</h4><p><strong>Algorithm 1</strong> Iterative SMO training algorithm</p><hr><p><strong>Initialization:</strong><br>​    初始化 $\lambda_{\mathrm{V}}, R, \mathcal{C}, \mathbf{U}=\mathbf{c}^{m}, \mathbf{c}^{n},(m=1, n=2), N_{\mathrm{OBU}}, N_{\mathrm{RV}}, J$<br><strong>Loop:</strong></p><ol><li><strong>while</strong>  $k \leftarrow\left{1,2, \ldots, N_{\mathrm{V}}\right}$  <strong>do</strong></li><li>​&emsp;根据 $\text{SNR}_{V,k}$ 和 $a_j$ 初始化训练样本 $\mathbf{x}_j$, 标签 $y_j$, $(j \in{1,2, \ldots, J})$</li><li>​&emsp;&emsp;<strong>for all</strong> $m, n \leq N^{\mathcal{C}},(m \neq n)$ <strong>do</strong></li><li>​&emsp;&emsp;&emsp;&emsp;选择不满足式(15)的三个条件的 $a_{j_1}$</li><li>​&emsp;&emsp;&emsp;&emsp;选择拥有 $E_{j_{1}}-E_{j_{2}}$ 最大值的 $a_{j_2}$</li><li>​&emsp;&emsp;&emsp;&emsp;混合所有的 $a_{j}, j \in J \backslash\left{j_{1}, j_{2}\right}$,计算 $\rho,a_L,a_H,\zeta$</li><li>​&emsp;&emsp;&emsp;&emsp;按照式(20)计算 $a_{j_{2}}^{ {new }}$ 的值, 更新 $E_{j_1},E_{j_2}$ 的值</li><li>​&emsp;&emsp;&emsp;&emsp;按照式(21)更新 $a_{j_{1}}^{ {new }}$ 的值.</li><li>​&emsp;&emsp;&emsp;&emsp;<strong>if</strong> 所有的 $a_j$ 都满足式(15)的三个条件 <strong>then</strong></li><li>​&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;保存所有的 $a_j$ 作为 $\mathbf{c}^{m}, \mathbf{c}^{n}$ 之间的分离超平面 $SP^{m,n}$ 的系数</li><li>​&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;更新子集 $\mathbf{U}$ 的 $\mathbf{c}^{m}, \mathbf{c}^{n}$</li><li>​&emsp;&emsp;&emsp;&emsp;<strong>end if</strong></li><li>​&emsp;&emsp;<strong>end for</strong></li><li><strong>end while</strong></li></ol><p><strong>Output:</strong> 在 $\mathbf{c}^{m}, \mathbf{c}^{n}, \left(m, n \leq N^{\mathcal{C}}, m \neq n\right)$ 之间的所有分离超平面 $SP^{m,n}$ 的系数 $a_j,(j \in{1,2, \ldots, J})$</p><hr><p><strong>算法1</strong> 展示了ML训练过程。输出的是所有分离的超平面的系数。根据Osuna ‘s定理[11]，每次迭代都会减少目标函数(13)，即保证收敛性。</p><p>接下来，我们将进一步比较两种传统的算法，即<strong>基于速率的算法</strong>和<strong>信道估计算法</strong>的计算复杂度。基于速率的算法计算所有可能的模拟波束的ASR值。然后，算法选择能够达到最大ASR的模拟波束作为信号传输的最佳模拟波束。由于波束的每一个向量都是一个 $N_{OBU}$ 维的向量，信道矩阵 $\mathbf{H}<em>\text{V,k}$ 是一个 $N</em>{OBU}$ 维的方阵。因此，每个 VUE 发送端的计算复杂度是 $\mathcal{O}(N_{OBU}^5)$。如前所述，用来选择的候选波束有 $N_\mathcal{C}$ 个。该计算复杂度为：<br>$$<br>\mathcal{O}\left[N_{\mathcal{C}} N_{\mathrm{OBU}}^{5} \frac{N_{\mathrm{V}}\left(1+N_{\mathrm{V}}\right)}{2}\right]=\mathcal{O}\left[\frac{1}{2} N_{\mathcal{C}} N_{\mathrm{OBU}}^{5}\left(N_{\mathrm{V}}^{2}+N_{\mathrm{V}}\right)\right]\tag{22}<br>$$<br>然后，信道估计算法根据所有 $L$ 信道路径的CSI选择最佳的模拟波束。每个 VUE 发送端的计算复杂度是 $\mathcal{O}(LN_{OBU}^3)$，该计算复杂度满足：<br>$$<br>\mathcal{O}\left[L N_{\mathcal{C}} N_{\mathrm{OBU}}^{3} \frac{N_{\mathrm{V}}\left(1+N_{\mathrm{V}}\right)}{2}\right]=\mathcal{O}\left[\frac{L}{2} N_{\mathcal{C}} N_{\mathrm{OBU}}^{3}\left(N_{\mathrm{V}}^{2}+N_{\mathrm{V}}\right)\right]\tag{23}<br>$$<br>最后，本文提出的SVM分类器如果应用于波束选择，必须经过良好的训练，即预先离线进行数据训练（文献17中得知）。因此，数据训练造成的复杂性可以排除。因此，根据前面的分析，可以得到 $\frac{1}{2}\left(N_{\mathcal{C}}\right)^{2}$ 个分离的超平面。每轮迭代之后，超平面的数量都会减半。为了决定测试向量的方向进行的对比包括 $N_{OBU}$ 次乘和加。所以，每一轮的迭代的计算复杂度是 $\mathcal{O}(2N_{OBN})$ 。每一个 VUE 发送端的计算复杂度是 $\mathcal{O}\left[\left(1-\frac{1}{2^{N_{\mathcal{C}}-1}}\right) N_{\mathcal{C}}^{2} N_{\mathrm{OBU}}\right]$。此外，因为平均下来有 $N_{\mathrm{V}}=\left\lfloor\lambda_{\mathrm{V}} \pi R^{2}\right\rfloor$ 个VUE 发送端，所以我们提出的算法的计算复杂度满足：<br>$$<br>\begin{array}{l}\mathcal{O}\left[\frac{N_{C}^{2}}{2} N_{\mathrm{OBU}} \frac{N_{\mathrm{V}}\left(1+N_{\mathrm{V}}\right)}{2}\left(1-\frac{1}{2^{N_{\mathcal{C}}-1}}\right)\right] \=\mathcal{O}\left[N_{\mathcal{C}}^{2} N_{\mathrm{OBU}}\left(N_{\mathrm{V}}^{2}+N_{\mathrm{V}}\right)\left(\frac{1}{4}-\frac{1}{2^{N_{\mathcal{C}}+1}}\right)\right]\end{array}\tag{24}<br>$$</p><h3 id="5-仿真讨论"><a href="#5-仿真讨论" class="headerlink" title="5.仿真讨论"></a>5.仿真讨论</h3><p>在这一部分，我们通过 Google TensorFlow 对建议的分类器进行训练和评估，其中使用四张 Nvidia Geforce GTX 显卡来加速样本训练。仿真参数见下表。</p><table><thead><tr><th align="center">Parameter</th><th align="center">Connotation</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">$\lambda$</td><td align="center">V2V link density<br>V2V链路密度</td><td align="center">$1 \times 10^{-5} \text{V2V link}/m^2$</td></tr><tr><td align="center">$P_V$</td><td align="center">Maximum VUE TX power<br>VUE 最大发送功率</td><td align="center">$29dBm$</td></tr><tr><td align="center">$L$</td><td align="center">Propagation path number<br>传播路径数量</td><td align="center">$2$</td></tr><tr><td align="center">$N_{OBU}$</td><td align="center">Antenna number of OBU<br>车载单元天线数量</td><td align="center">$32$</td></tr><tr><td align="center">$R$</td><td align="center">Maximum VUE communication radius<br>VUE 最大通信半径</td><td align="center">$20m$</td></tr><tr><td align="center">$N_\mathcal{C}$</td><td align="center">Number of all candidate vectors<br>所有候选向量数量</td><td align="center">$8$</td></tr></tbody></table><p>如图2所示，随着 V2V 链路密度的增加，VANET 的 ASR 增加。这是因为更多的 VUE发送端 可以为 VUE接收端 提供更多的通信链路，从而增加低传播损失传输的概率。当 V2V 链路密度持续增加时，ASR 的上升趋势变得缓慢，这意味着几乎所有 VUE接收端 都可以由 VUE发送端 提供。该算法比基于通道估计的现有光束选择算法性能更好，更接近理论最优边界。这是因为 ML 培训可以深入提取系统功能。通道估计算法的性能比建议的算法差，因为它只基于CSI，而CSI只被认为是系统功能的一部分。</p><img src="https://i.bmp.ovh/imgs/2021/03/9d512c37b9161277.png" alt width="400" align="bottom"><p>图三给出了基于速率算法、基于信道估计算法分别与我们的算法的计算复杂度的比较。可以看出，本文提出的算法在计算复杂度上有明显的降低，特别是当VUE链路数量变大时。通过迭代1v1 SVM分类，VUE发送端 可以根据其经过良好训练的分类模型直接选择最佳的模拟波束，而不是尝试所有的模拟波束。因此，该算法的复杂度大大降低。</p><img src="https://i.bmp.ovh/imgs/2021/03/b677be393e571c76.png" width="400" align="bottom"><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>本文考虑了基于 ML 的模拟光束毫米波 VANET 中 V2V 通信的选择方法。我们将 V2V 链路建模为 HPPP，以派生 VANETS 的 ASR。此外，还提出了用于选择每个 VUE 的模拟光束的迭代 1v1 SVM 分类器。然后，利用迭代SMO算法获取分离的超平面，使VUE TX快速、准确地选择复杂度极低的模拟光束。仿真结果表明，该算法对理论上边界实现了非常封闭的性能。此外，结果还验证了我们提出的算法不仅得到了比传统信道估计算法更高的 ASR，而且实现了计算复杂性的大幅降低。最后，请注意，我们建议的 ML 分类器仅在 VUE 位置在不同时间更改的动态条件下使用。如果考虑 VUE 的速度，场景的动态性质将变得更加复杂，这显示了我们未来研究工作的有趣和具有挑战性的主题。</p><blockquote><p><strong>V2V:</strong><br>V2V(虚拟机到虚拟机的迁移，Virtual to Virtual)，又称虚拟机的克隆。<br>V2V迁移是在虚拟机之间移动操作系统和数据，照顾物理机级别的差异和处理不同的虚拟硬件。虚拟机从一个物理机上的虚拟机监视器迁移到另一个物理机的虚拟机监视器，这两个虚拟机监视器的类型可以相同，也可以不同。如VM ware迁移到KVM，KVM迁移到KVM。可以通过多种方式将虚拟机从一个VM Host系统移动到另一个VM Host系统。</p><p><strong>HPPP:</strong> 异构泊松点过程</p><p><strong>VANET:</strong><br>车载随意移动网络（英语：Vehicular ad-hoc network，缩写为VANET），又称车用移动通信网络，一种移动通信技术，以移动中的车辆及交通设施为节点，利用无线通信技术，来形成移动网络。</p><p><strong>ASR:</strong> 平均传输速率</p><p><strong>VUE TX:</strong> 发送端</p><p><strong>VUE RX:</strong> 接收端</p><p><strong>SVM:</strong><br>支持向量机（Support Vector Machine, SVM）是一类按监督学习（supervised learning）方式对数据进行二元分类的广义线性分类器（generalized linear classifier），其决策边界是对学习样本求解的最大边距超平面（maximum-margin hyperplane）。<br>SVM使用铰链损失函数（hinge loss）计算经验风险（empirical risk）并在求解系统中加入了正则化项以优化结构风险（structural risk），是一个具有稀疏性和稳健性的分类器。SVM可以通过核方法（kernel method）进行非线性分类，是常见的核学习（kernel learning）方法之一。<br>SVM被提出于1964年，在二十世纪90年代后得到快速发展并衍生出一系列改进和扩展算法，在人像识别、文本分类等模式识别（pattern recognition）问题中有得到应用。</p><p><strong>SMO:</strong><br>序列最小优化算法（Sequential minimal optimization, SMO）是一种用于解决[支持向量机]训练过程中所产生优化问题的算法。SMO由微软研究院的约翰·普莱特于1998年发明，被广泛使用于SVM的训练过程中，并在通行的SVM库LIBSVM中得到实现。1998年，SMO算法发表在SVM研究领域内引起了轰动，因为先前可用的SVM训练方法必须使用复杂的方法，并需要昂贵的第三方二次规划工具。而SMO算法较好地避免了这一问题。</p><p><strong>CSI:</strong><br>Channel State Information :信道状态信息.，在无线通信领域，所谓的CSI，就是通信链路的信道属性。它描述了信号在每条传输路径上的衰弱因子，即信道增益矩阵H中每个元素的值，如信号散射（Scattering）,环境衰弱（fading，multipath fading or shadowing fading）,距离衰减（power decay of distance）等信息。CSI可以使通信系统适应当前的信道条件，在多天线系统中为高可靠性高速率的通信提供了保障。<br>一般情况下，接收端评估CSI并将其量化反馈给发送端（在时分双工系统中，需要反向评估）。因此CSI可分为CSIR和CSIT。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目构建-音乐播放器-vuejs实战项目</title>
      <link href="2021/02/03/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8-vuejs%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
      <url>2021/02/03/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8-vuejs%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>现在市面上比较流行的音乐app有：网易云音乐、QQ音乐、虾米音乐、咪咕音乐、酷狗音乐等</p><p>本人使用的主要是网易云音乐和QQ音乐，学习了一段时间的Vuejs之后，想要使用这门手艺去做一些东西，首当其冲地想到了音乐app，在这里记录下项目的初始化构建，后期也会不断完善，更新项目进度</p></blockquote><h3 id="总体路由组件"><a href="#总体路由组件" class="headerlink" title="总体路由组件"></a>总体路由组件</h3><h4 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h4><ul><li>顶部导航栏<ul><li>设置栏</li><li>搜索栏</li><li>听歌识曲</li></ul></li><li>轮播图</li><li>按钮阵列</li><li>推荐歌单</li><li>私人定制</li><li>专属场景歌单</li><li>播客合辑</li><li>视频合辑</li></ul><h4 id="歌单广场"><a href="#歌单广场" class="headerlink" title="歌单广场"></a>歌单广场</h4><h4 id="歌单"><a href="#歌单" class="headerlink" title="歌单"></a>歌单</h4><ul><li>顶部导航栏<ul><li>返回按钮</li><li>搜索按钮</li><li>更多按钮</li></ul></li><li>歌单信息<ul><li>歌单封面</li><li>歌单名称</li><li>作者名称</li><li>歌单描述</li></ul></li><li>歌单数据信息<ul><li>收藏数</li><li>评论数</li><li>分享数</li></ul></li><li>控制栏<ul><li>播放全部</li><li>下载全部</li><li>收藏全部</li></ul></li><li>歌单歌曲单元<ul><li>序号</li><li>歌曲信息<ul><li>歌曲名称</li><li>歌手名称</li></ul></li><li>更多按钮</li></ul></li></ul><h4 id="播放页"><a href="#播放页" class="headerlink" title="播放页"></a>播放页</h4><ul><li>顶部导航栏<ul><li>返回按钮</li><li>歌曲信息</li><li>分享按钮</li></ul></li><li>播放界面<ul><li>旋转专辑封面</li><li>滚动歌词</li></ul></li><li>按钮阵列<ul><li>收藏</li><li>下载</li><li>K歌</li><li>评论</li><li>更多</li></ul></li><li>播放进度<ul><li>当前时间</li><li>进度条</li><li>总时间</li></ul></li><li>歌曲控制<ul><li>循环类型</li><li>上一首</li><li>播放/暂停</li><li>下一首</li><li>播放列表</li></ul></li></ul><h4 id="云村"><a href="#云村" class="headerlink" title="云村"></a>云村</h4><h4 id="我的"><a href="#我的" class="headerlink" title="我的"></a>我的</h4>]]></content>
      
      
      
        <tags>
            
            <tag> vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目发布app（安卓）</title>
      <link href="2021/02/02/Vue%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app%EF%BC%88%E5%AE%89%E5%8D%93%EF%BC%89/"/>
      <url>2021/02/02/Vue%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app%EF%BC%88%E5%AE%89%E5%8D%93%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这段时间学习完vue之后，就做了一个模仿网易云音乐的music项目，博主本人平日里也非常喜欢听音乐，现在学了前端技术之后，就忍不住想要用科技改变生活，想要听歌的话，又何必下那么多app呢？</p></blockquote><blockquote><p>于是一周的时间做出来了一个勉强能用的音乐app</p></blockquote><h1 id="但是！"><a href="#但是！" class="headerlink" title="但是！"></a>但是！</h1><h4 id="很明显这不足以是一个成熟的app，所以博主就想试着打包成安卓app所用的apk安装包，从而在手机可以使用，而不是在浏览器简陋地使用"><a href="#很明显这不足以是一个成熟的app，所以博主就想试着打包成安卓app所用的apk安装包，从而在手机可以使用，而不是在浏览器简陋地使用" class="headerlink" title="很明显这不足以是一个成熟的app，所以博主就想试着打包成安卓app所用的apk安装包，从而在手机可以使用，而不是在浏览器简陋地使用"></a>很明显这不足以是一个成熟的app，所以博主就想试着打包成安卓app所用的apk安装包，从而在手机可以使用，而不是在浏览器简陋地使用</h4><p>查询到多种方式，最后还是选择了<strong>最简单</strong>的使用HBuilderX来打包</p><p>接下来就对于步骤进行简单的记录</p><ul><li>第一步：打包vue项目</li><li>第二步：HBuilder新建<code>5+app</code>项目</li><li>第三步：将打包好的dist文件夹上传到新建项目中</li><li>第四步：进行打包的相关配置（简单化：所有功能都不选择</li><li>第五步：点击运行选择第一个云打包</li><li>第六步：在手机浏览器输入云打包生成的链接，即可下载apk安装包</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><ul><li>如果云打包失败，可以选择传统打包方式</li><li>尽量不要选择无用的功能</li><li>下载链接只有5个下载名额</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>希望可以在过年之前把这个音乐播放器项目更加完善，把bug全部消灭</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 - 1024 = 996</title>
      <link href="2020/10/24/blog-1024/"/>
      <url>2020/10/24/blog-1024/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>每一个程序员学一门语言的第一件事，就是特别开心自己的代码让电脑上显示了一行<code>hello world</code><br>每一个程序员都会把<code>hello world</code>当作自己开始学习了一门语言<br>每一个程序员……</p><p><strong>可是，我还并不是一个程序员<br>所以我想象之中的‘每一个程序员’，<br>其实也就是我自己想要成为的程序员的模样</strong></p><p>明日复明日，明日何其多，如果早一点坚定自己的方向，朝着正确的方向前进<br>你的步伐一定会比现在快很多</p><p><code>编程</code>是我大学四年来，找到的一件我真正深爱的事情<br>我不怕<code>WARN</code>，也不怕<code>error</code>，<br>我所怕的是，将来的我没办法走在这条道路上<br>我不信奉<code>996</code>是一种福报，<br>但我也绝不抵触抵触他</p><p>干一行爱一行，这是老祖先教会我们的事情<br>有志者事竟成，愿世界和平，没有bug</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>        </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello,World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sys = <span class="built_in">require</span>(<span class="string">&quot;sys&quot;</span>);</span><br><span class="line">sys.puts(<span class="string">&quot;Hello,World!&quot;</span>); </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的作品</title>
      <link href="2020/10/22/works/"/>
      <url>2020/10/22/works/</url>
      
        <content type="html"><![CDATA[<h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><p><img src="/web-%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="web-爬虫数据可视化"><br><img src="/2020/10/22/works/web-%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="web-爬虫数据可视化"><br><img src="//web-%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="web-爬虫数据可视化"></p><h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h3 id="小程序-选课宝"><a href="#小程序-选课宝" class="headerlink" title="小程序-选课宝"></a>小程序-选课宝</h3><img src="/2020/10/22/works/小程序-选课宝.png" width="65%" text="小程序-选课宝"><h3 id="小程序-轴承故障预测"><a href="#小程序-轴承故障预测" class="headerlink" title="小程序-轴承故障预测"></a>小程序-轴承故障预测</h3><img src="/2020/10/22/works/小程序-轴承故障检测.png" width="65%" text="小程序-轴承故障检测"><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><!-- ![vue-仿网易云](vue-仿网易云.png) --><img src="/2020/10/22/works/vue-%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91.png" class title="这是一张图片"><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><!-- ![客户端-成本分析系统](客户端-成本分析系统.png) --><img src="/2020/10/22/works/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F.png" class title="这是一张图片"><!-- ![客户端-事件管理系统](客户端-事件管理系统.png) --><img src="/2020/10/22/works/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.png" class title="这是一张图片">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
